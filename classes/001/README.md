# Class 001 - The Machine Abstraction
## What is a computer
The computer is a complicated light switch, its essence are switches that turn on and off, arranged in a way that switching one key will affect the end result.

Each key sequence is set for a specific purpose, this way, countless combinations are possible to be made resulting in a vast range of possibilities.

Switching this keys in a sequential form allows the computer to perform highly complex tasks, however the principle is very simple, works exactly like a light switch.

## How does he works

Everything in computer science is about inputs and outputs, if I turn on this switch, that lamp will light, if I turn on these 3 switches, that other lamp will light.

Now imagine billions of switches e billions of lamps, if I put 10 thousand switches in the right position the computer will turn on 4 hundred lamps and show the letter A on my screen, or if I turn on and off theses 100 thousand switches in a given order, the computer will send my email.

The switches are called transistors and the lamps can be any thing controlled by the output of this transistors, even other transistors.

## How it communicate

To speak with this entities, is used something called machine language, which are the famous zeros and ones, that are nothing more than instructions of which switches to turn on or of, however for us humans it doesn't make any sense, so here is where programing languages enters the play.

Programming is nothing more than the abstraction of these zeros and ones in a language closer to the human language,the higher the level of the programming language, closer it will be from or own language, making easier to people to communicate with the machine.

## Speaking better

The study of software development has the intention of perfect the way we communicate with machines, because it's not only about writing code, it also involves the way we organize our code, our intentions and expected results, the protective measures we adopt, and other things that grow the complexity in an exponential fashion.

## Small Projects

We should think in small portions of bigger problems, trying to isolate the concepts, the best we can, so that don't became impossible to explain.

The idea behind small projects is to understand how to develop parts, this way, regardless of the project size we always will have to work with small parts responsible for a single thing.

## Growing Projects

Always thinking in small projects, with a very well defined functionality, we can start to think in big projects as a group of small things acting together to do big tasks, remember the switches? Well, the same principle applies here, using a sequence of small projects is possible to do countless tasks.

## Finishing Projects

Having or intentions defined, inputs and expected outputs, we can use the small projects to reach our goals.

All concepts in computer science repeat themselves, only changing the scale in which is used.

A project can be called finished when applied a series of well defined inputs, generates the expected result. This is valid for any size project.

In case the expected result changes, it can be considered a new project, that needs to adapt to the new scenario.

## References
[Crash Course Computer Science](https://youtu.be/tpIctyqH29Q)
